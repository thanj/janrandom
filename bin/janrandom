#!/usr/bin/env ruby

# == Synopsis
#   Janrain Random User Generator
#   Blah blah blah.
#
# == Examples
#   Initialize your app for random user generation:
#   (This will prompt you for Capture domain, client id, and secret,
#   and save those credentials, as well as the app schema in a config file)
#     janrandom init myapp
#
#   Create 100 random users in your Janrain Capture app
#     janrandom create myapp 100
#
#   Uncreate all random users created with this script:
#     janrandom uncreate myapp
#
#   Remove the "janrandomIsAutoGenerated" flag from the app schema:
#     janrandom uninit myapp
#
# == Usage
#   janrandom create {app} [number]
#
#   For help use: janrandom -h
#
# == Options
#   -h, --help          Displays help message
#   -v, --version       Display the version, then exit
#   -q, --quiet         Output as little as possible, overrides verbose
#   -V, --verbose       Verbose output
#   TO DO - add additional options
#
# == Author
#   Janrain
#
# == Copyright
#   Copyright (c) 2013 Janrain. Licensed under the MIT License:
#   http://www.opensource.org/licenses/mit-license.php

require 'thor'
require 'highline/import'
require 'yaml'
require 'rest_client'
require 'faker'
require 'terminal-table'

class JanRandom < Thor
  option :verbose, :type => :boolean

  desc "apps", "display a list of Capture apps configured for janrandom"
  def apps()
    read_options

    puts 'Apps available to JRUG:'
    @apps.each_key { |key| puts key }
  end


  desc "init APP", "set up APP for random-user generation"
  def init(app)
    read_options

    if @apps && @apps.has_key?(app)
      puts 'Using credentials from janrandom.appconfig file...'
      appoptions = @apps[app]
    else
      puts "Enter credentials for #{app}...\n"
      appoptions = Hash.new
      appoptions[:server]       = ask("Capture Server?  ") { |q| q.default = app }
      appoptions[:clientid]     = ask("Client ID?       ") { |q| q.default = "none" }
      appoptions[:clientsecret] = ask("Client Secret?   ") { |q| q.echo    = "x" }
      @apps[app] = appoptions
      File.open(@config_file, 'w') { |f| YAML.dump(@apps, f) }
    end

    entityType = RestClient.post( "https://#{appoptions[:server]}/entityType",
      {
        :client_id     => appoptions[:clientid],
        :client_secret => appoptions[:clientsecret],
        :type_name     => 'user'
      }
    )

    attrDefs = JSON.parse( entityType )

    @schema = { }
    parse_attr_defs( attrDefs['schema']['attr_defs'] )

    # If there's no "janRandomGenerated" attribute in the schema, add it now
    unless @schema.has_key?('janRandomGenerated')
      RestClient.post( "https://#{appoptions[:server]}/entityType.addAttribute",
        {
          :client_id     => appoptions[:clientid],
          :client_secret => appoptions[:clientsecret],
          :type_name     => 'user',
          :attr_def      => '{"name":"janRandomGenerated","type":"string","length":1}'
        }
      )
    end

    @apps[app][:schema] = @schema
    File.open(@config_file, 'w') { |f| YAML.dump(@apps, f) }

    puts "Successfully prepared app #{app} for random user generation."
  end


  desc "create APP [NUMBER]", "create NUMBER (defaults to 10) dummy users for the Capture app APP"
  def create(app, number = 10)
    read_options

    unless @apps.has_key?(app)
      puts "#{app} has not been initialized to JRUG yet. Try running `janrandom init #{app}` first."
      exit
    end

    puts "Creating #{number} randomized users for #{app}:"

    randomUsers = [ ]
    number.to_i.times do
      user = UserAttrs.new()
      record = { }
      @apps[app][:schema].each do |attr,meth|
        if meth.is_a?(String) && UserAttrs.method_defined?(meth)
          record[attr] = user.send(meth)
        end
      end

      randomUsers << record
      user = nil
    end

    appoptions = @apps[app]

    createdUsers = RestClient.post( "https://#{appoptions[:server]}/entity.bulkCreate",
      {
        :client_id      => appoptions[:clientid],
        :client_secret  => appoptions[:clientsecret],
        :type_name      => 'user',
        :all_attributes => JSON.dump(randomUsers)
      }
    )

    apiResponse = JSON.parse( createdUsers )

    tableRows = apiResponse['uuid_results'].zip(
      randomUsers.collect { |n| n['displayName'] },
      randomUsers.collect { |n| n['email'] },
      randomUsers.collect { |n| n['currentLocation'] }
    )

    table = Terminal::Table.new :rows => tableRows
    puts table
  end


  desc "uncreate APP", "uncreate (bulk delete) dummy users created for the Capture app APP"
  def uncreate(app)

    read_options
    unless @apps.has_key?(app)
      puts "#{app} has not been initialized to JRUG yet. Try running `janrandom init #{app}` first."
      exit
    end

    appoptions = @apps[app]

    deletedUsers = RestClient.post( "https://#{appoptions[:server]}/entity.bulkDelete",
      {
        :client_id     => appoptions[:clientid],
        :client_secret => appoptions[:clientsecret],
        :type_name     => 'user',
        :filter        => 'janRandomGenerated is not null',
        :commit        => true
      }
    )

    apiResponse = JSON.parse( deletedUsers )
    if apiResponse.has_key?('delete_count')
      puts ( apiResponse['delete_count'] > 0 ) ?
        "Successfully deleted #{apiResponse['delete_count']} random people from #{app}." :
        "No random users left to delete from this app!"
    else
      puts "Error deleting users."
      puts apiResponse
    end

  end

  no_commands {
    def read_options
      @config_file = File.expand_path("~/janrandom.appconfig")
      if File.exist?(@config_file)
        @apps = YAML::load( File.open(@config_file) )
      else
        @apps = { }
      end
    end

    def parse_attr_defs( entity, depth = false )
      entity.each { |attr|
        if attr['name']
          attr_method = UserAttrs.method_defined?(attr['name']) ? attr['name'] : attr['type']
          if attr['attr_defs']
            @schema[ attr['name'] ] = parse_attr_defs( attr['attr_defs'], "#{depth}#{attr['name']}." )
          else UserAttrs.method_defined?(attr['name'])
            attr_method = UserAttrs.method_defined?(attr['name']) ? attr['name'] : attr['type']
            if depth
              return attr_method
            else
              @schema[ attr['name'] ] = attr_method
            end
          end
        end
      }
    end

  }
end


class UserAttrs
  def initialize
    @aboutMe
    @birthday
    @givenName
    @middleName
    @displayName
    @familyName
    @email
    @currentLocation
    @gender
  end

  def aboutMe
    @aboutMe ||= Faker::Lorem.paragraph
  end

  def birthday
    return '1974-07-08'
  end

  def givenName
    @givenName ||= Faker::Name.first_name
  end

  def middleName
    @middleName ||= Faker::Name.first_name
  end

  def displayName
    @displayName ||= [givenName(),familyName()].join(' ')
  end

  def familyName
    @familyName ||= Faker::Name.last_name
  end

  def email
    @email ||= Faker::Internet.email([givenName(),familyName()].join(' '))
  end

  def currentLocation
    @currentLocation ||= Faker::Address.city + ', ' + Faker::Address.state
  end

  def gender
    @gender ||=  ['male', 'female'].sample
  end

  def janRandomGenerated
    "Y"
  end
end


# Create and run the application
JanRandom.start(ARGV)
