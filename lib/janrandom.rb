# == Synopsis
#   Janrain Random User Generator
#   Blah blah blah.
#
# == Examples
#   Initialize your app for random user generation:
#   (This will prompt you for Capture domain, client id, and secret,
#   and save those credentials, as well as the app schema in a config file)
#     janrandom init myapp
#
#   Create 100 random users in your Janrain Capture app
#     janrandom create myapp 100
#
#   Uncreate all random users created with this script:
#     janrandom uncreate myapp
#
#   Remove the "janrandomIsAutoGenerated" flag from the app schema:
#     janrandom uninit myapp
#
# == Usage
#   janrandom create {app} [number]
#
#   For help use: janrandom -h
#
# == Options
#   -h, --help          Displays help message
#   -v, --version       Display the version, then exit
#   -q, --quiet         Output as little as possible, overrides verbose
#   -V, --verbose       Verbose output
#   TO DO - add additional options
#
# == Author
#   Janrain
#
# == Copyright
#   Copyright (c) 2013 Janrain. Licensed under the MIT License:
#   http://www.opensource.org/licenses/mit-license.php

require 'i18n'
I18n.load_path += Dir[File.join(File.expand_path(File.dirname(__FILE__)),'data','*.yml')]
I18n.locale = 'en-janrain'

require 'thor'
require 'highline/import'
require 'yaml'
require 'rest_client'
require 'faker'
require 'terminal-table'

class JanRandom < Thor
  option :verbose, :type => :boolean

  desc "apps", "display a list of Capture apps configured for janrandom"
  def apps()
    read_options

    puts 'Apps available to janrandom:'
    @apps.each_key { |key| puts key }
  end


  desc "init APP", "set up APP for random-user generation"
  def init(app)
    read_options

    if @apps && @apps.has_key?(app)
      puts 'Using credentials from janrandom.appconfig file...'
      appoptions = @apps[app]
    else
      puts "Enter credentials for #{app}...\n"
      appoptions = Hash.new
      appoptions[:server]       = ask("Capture Server?  ") { |q| q.default = app }
      appoptions[:clientid]     = ask("Client ID?       ") { |q| q.default = "none" }
      appoptions[:clientsecret] = ask("Client Secret?   ") { |q| q.echo    = "x" }
      @apps[app] = appoptions
      File.open(@config_file, 'w') { |f| YAML.dump(@apps, f) }
    end

    entityType = RestClient.post( "https://#{appoptions[:server]}/entityType",
      {
        :client_id     => appoptions[:clientid],
        :client_secret => appoptions[:clientsecret],
        :type_name     => 'user'
      }
    )

    attrDefs = JSON.parse( entityType )

    @schema = { }
    parse_attr_defs( attrDefs['schema']['attr_defs'] )

    # If there's no "janRandomGenerated" attribute in the schema, add it now
    unless @schema.has_key?('janRandomGenerated')
      RestClient.post( "https://#{appoptions[:server]}/entityType.addAttribute",
        {
          :client_id     => appoptions[:clientid],
          :client_secret => appoptions[:clientsecret],
          :type_name     => 'user',
          :attr_def      => '{"name":"janRandomGenerated","type":"string","length":1}'
        }
      )
    end

    @apps[app][:schema] = @schema
    File.open(@config_file, 'w') { |f| YAML.dump(@apps, f) }

    puts "Successfully prepared app #{app} for random user generation."
  end


  desc "create APP [NUMBER]", "create NUMBER (defaults to 10) dummy users for the Capture app APP"
  def create(app, number = 10)
    read_options

    unless @apps.has_key?(app)
      puts "#{app} has not been initialized to JRUG yet. Try running `janrandom init #{app}` first."
      exit
    end

    puts "Creating #{number} randomized users for #{app}:"

    randomUsers = [ ]
    number.to_i.times do
      user = UserAttrs.new()
      record = { }
      @apps[app][:schema].each do |attr,meth|
        if meth.is_a?(String) && UserAttrs.method_defined?(meth)
          record[attr] = user.send(meth)
        end
      end

      randomUsers << record
      user = nil
    end

    appoptions = @apps[app]

    createdUsers = RestClient.post( "https://#{appoptions[:server]}/entity.bulkCreate",
      {
        :client_id      => appoptions[:clientid],
        :client_secret  => appoptions[:clientsecret],
        :type_name      => 'user',
        :all_attributes => JSON.dump(randomUsers)
      }
    )

    apiResponse = JSON.parse( createdUsers )

    tableRows = apiResponse['uuid_results'].zip(
      randomUsers.collect { |n| n['displayName'] },
      randomUsers.collect { |n| n['email'] },
      randomUsers.collect { |n| n['currentLocation'] }
    )

    table = Terminal::Table.new :rows => tableRows
    puts table
  end


  desc "uncreate APP", "uncreate (bulk delete) dummy users created for the Capture app APP"
  def uncreate(app)

    read_options
    unless @apps.has_key?(app)
      puts "#{app} has not been initialized to JRUG yet. Try running `janrandom init #{app}` first."
      exit
    end

    appoptions = @apps[app]

    deletedUsers = RestClient.post( "https://#{appoptions[:server]}/entity.bulkDelete",
      {
        :client_id     => appoptions[:clientid],
        :client_secret => appoptions[:clientsecret],
        :type_name     => 'user',
        :filter        => 'janRandomGenerated is not null',
        :commit        => true
      }
    )

    apiResponse = JSON.parse( deletedUsers )
    if apiResponse.has_key?('delete_count')
      puts ( apiResponse['delete_count'] > 0 ) ?
        "Successfully deleted #{apiResponse['delete_count']} random people from #{app}." :
        "No random users left to delete from this app!"
    else
      puts "Error deleting users."
      puts apiResponse
    end

  end

  desc "uninit APP", "remove the flag field added to app schema by this tool"
  def uninit(app)

    read_options
    unless @apps.has_key?(app)
      puts 'Invalid app name.'
      exit
    end

    # If there is a "janRandomGenerated" attribute in the schema, remove it now
    if @apps[app].has_key?('janRandomGenerated')
      apiResponse = RestClient.post( "https://#{appoptions[:server]}/entityType.removeAttribute",
        {
          :client_id     => appoptions[:clientid],
          :client_secret => appoptions[:clientsecret],
          :type_name     => 'user',
          :attr_name     => 'janRandomGenerated'
        }
      )
      puts apiResponse
    end
  end

  desc "test APP", "Dry-run, display a random user such as that would be generated for APP's schema"
  def test(app)
    read_options
    unless @apps.has_key?(app)
      puts 'Invalid app name.'
      exit
    end

    user = UserAttrs.new()
    record = { }
    @apps[app][:schema].each do |attr,meth|
      if meth.is_a?(String) && UserAttrs.method_defined?(meth)
        record[attr] = user.send(meth)
      end
    end

    table = Terminal::Table.new :rows => record
    puts table
  end

  no_commands {
    def read_options
      @config_file = File.expand_path("~/janrandom.appconfig")
      if File.exist?(@config_file)
        @apps = YAML::load( File.open(@config_file) )
      else
        @apps = { }
      end
    end

    def parse_attr_defs( entity, depth = false )
      entity.each { |attr|
        if attr['name']
          attr_method = UserAttrs.method_defined?(attr['name']) ? attr['name'] : attr['type']
          if attr['attr_defs']
            @schema[ attr['name'] ] = parse_attr_defs( attr['attr_defs'], "#{depth}#{attr['name']}." )
          else UserAttrs.method_defined?(attr['name'])
            attr_method = UserAttrs.method_defined?(attr['name']) ? attr['name'] : attr['type']
            if depth
              return attr_method
            else
              @schema[ attr['name'] ] = attr_method
            end
          end
        end
      }
    end

  }

end

module Faker
  class Base
    class << self

      def fetch_with_weighting(key)
        fetched = translate("faker.#{key}")
        num = rand(fetched.length) + rand(fetched.length) - fetched.length
        fetched = fetched[num.abs] if fetched.respond_to?(:sample)
        if fetched.match(/^\//) and fetched.match(/\/$/) # A regex
          regexify(fetched)
        else
          fetched
        end
      end

      def random_in_range( from, to )
        from, to = to, from if to < from
        rand * (to - from ) + from
      end

      def bell_random_in_range( from, to )
        from, to = to, from if to < from
        ( rand * (to - from ) + rand * (to - from ) ) / 2 + from
      end

    end
  end
end

class UserAttrs
  def initialize
    @aboutMe
    @birthday
    @givenName
    @middleName
    @displayName
    @familyName
    @email
    @currentLocation
    @gender
    @interests
    @music
    @movies
    @books
  end

  def aboutMe
    @aboutMe ||= Faker::Lorem.paragraph
  end

  def birthday
    now = Time.now().to_i()
    d = Faker::Base.bell_random_in_range( now - 13 * 365 * 24 * 3600, now - 60 * 365 * 24 * 3600 )
    Time.at(d).strftime('%Y-%m-%d')
  end

  def givenName
    gender = gender()
    @givenName ||= (gender == 'female') ?
        Faker::Base.fetch_with_weighting('name.female_name_common')
      : Faker::Base.fetch_with_weighting('name.male_name_common')
  end

  def middleName
    gender = gender()
    @middleName ||= (gender == 'female') ?
        Faker::Base.fetch_with_weighting('name.female_name_common')
      : Faker::Base.fetch_with_weighting('name.male_name_common')
  end

  def displayName
    @displayName ||= [givenName(),familyName()].join(' ')
  end

  def familyName
    @familyName ||= Faker::Name.last_name
  end

  def email
    @email ||= Faker::Internet.email([givenName(),familyName()].join(' '))
  end

  def currentLocation
    @currentLocation ||= Faker::Address.city + ', ' + Faker::Address.state
  end

  def gender
    @gender ||=  ['male', 'female'].sample
  end

  def interests
    @interests ||= Random.rand(12).times.map{ Faker::Base.fetch_with_weighting('lorem.interests') }.uniq
  end

  def music
    @music ||= Random.rand(12).times.map{ Faker::Base.fetch_with_weighting('lorem.music') }.uniq
  end

  def movies
    @movies ||= Random.rand(12).times.map{ Faker::Base.fetch_with_weighting('lorem.movies') }.uniq
  end

  def books
    @books ||= Random.rand(12).times.map{ Faker::Base.fetch_with_weighting('lorem.books') }.uniq
  end

  def janRandomGenerated
    "Y"
  end
end

# Create and run the application
JanRandom.start(ARGV)
